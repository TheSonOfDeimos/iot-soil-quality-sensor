import asyncio
from asyncio import Event
from sched.sched import schedule, Sequence
from time import localtime
from machine import Pin, ADC
from picozero.picozero import RGBLED
from primitives.pushbutton import Pushbutton
from primitives.aadc import AADC
import network, time, json
from umqtt.simple import MQTTClient
import sys
import time
import array
import ujson
import os

# https://github.com/peterhinch/micropython-async/blob/master/v3/docs/TUTORIAL.md

class Logger:
    # Severity levels
    DEBUG   = 10
    INFO    = 20
    WARNING = 30
    ERROR   = 40

    level_names = {
        DEBUG:   "DEBUG",
        INFO:    "INFO",
        WARNING: "WARN",
        ERROR:   "ERROR",
    }

    def __init__(self, level=INFO):
        self.level = level

    def set_level(self, level):
        self.level = level

    def log(self, level, msg):
        if level < self.level:
            return
        t = time.ticks_ms()  # uptime in ms
        level_name = self.level_names.get(level, "?")
        print(f"[{t:>8} ms ][ {level_name:5} ] {msg}")

    def debug(self, msg):   self.log(self.DEBUG, msg)
    def info(self, msg):    self.log(self.INFO, msg)
    def warning(self, msg): self.log(self.WARNING, msg)
    def error(self, msg):   self.log(self.ERROR, msg)

# --- Singleton instance ---
log = Logger()

class JsonFileUtil:
    def __init__(self, path: str):
        self.path = path

    def read(self, default=None):
        try:
            with open(self.path, "r") as f:
                data = ujson.load(f)
            log.debug(f"Loaded JSON from {self.path}: {data}")
            return data
        except OSError:
            log.debug(f"No file found: {self.path}")
            return default
        except ValueError as e:
            log.debug(f"Invalid JSON in {self.path}: {e}")
            return default

    def rewrite(self, obj):
        try:
            with open(self.path, "w") as f:
                ujson.dump(obj, f)
            log.debug(f"Wrote JSON to {self.path}: {obj}")
        except OSError as e:
            log.debug(f"Error writing {self.path}: {e}")
            raise

    def delete(self) -> bool:
        try:
            os.remove(self.path)
            log.debug(f"Deleted file: {self.path}")
            return True
        except OSError:
            log.debug(f"No file to delete: {self.path}")
            return False

def percentile(data, q) -> float :
    if not isinstance(data, array.array):
        raise TypeError("data must be array.array")
    n = len(data)
    if n == 0:
        raise ValueError("empty array")

    values = sorted(data)
    rank = (q / 100) * (n - 1)
    i = int(rank)
    frac = rank - i
    if i + 1 < n:
        return values[i] + (values[i+1] - values[i]) * frac
    else:
        return float(values[i])
    
def average(data : array.array) -> float :
    if not isinstance(data, array.array):
        raise TypeError("data must be array.array")
    n = len(data)
    if n == 0:
        raise ValueError("empty array")
    return sum(data) / n

def percentage_in_bounds(value, lower, upper) -> float :
    if lower == upper:
        raise ValueError("lower and upper bounds must differ")
    return min(100.0, max(0.0, (value - lower) * 100.0 / (upper - lower)))

class StatusLed :
    def __init__(self, led : RGBLED) -> None:
        self._led = led
        self._led.off()

    def idle(self):
        self._led.off()

    def soil_moisture(self, moisture_level : int, left_bound : int = 0, right_bound : int = 100):
        if moisture_level < left_bound or moisture_level > right_bound :
            raise Exception("Out of bounds")
        
        green = (255 / 100) * moisture_level
        red = 255 - green
        self._led.color = (red, green, 0)

    def start_calibration_soil_moisture_when_dry(self):
        self._led.blink(on_times=0.2, colors=((1,0,0), (0,0,0)))
        
    def calibrating_soil_moisture_when_dry(self):
        self._led.pulse(colors=((0, 0, 0), (1, 0, 0)))
    
    def start_calibration_soil_moisture_when_wet(self):
        self._led.blink(on_times=0.2, colors=((0,1,0), (0,0,0)))

    def calibrating_soil_moisture_when_wet(self):
        self._led.pulse(colors=((0, 0, 0), (0, 1, 0)))

    def measuring_soil_moisture(self):
        self._led.cycle(fade_times=0.7, colors=((1,0,0), (0,1,0)), fps=100)

    def connecting_to_network(self):
        self._led.pulse(colors=((0, 0, 0), (0, 0, 1)))

    def device_ready(self):
        self._led.blink(on_times=0.2, colors=((0, 1, 0), (0, 0, 0)))

    def user_error(self):
        self._led.blink(on_times=0.1, colors=((1,0,0), (0,0,1)))

    def internal_error(self):
        self._led.blink(on_times=0.1, colors=((0,0,1), (1,0,0)))

    def fatal_error(self):
        self._led.blink(on_times=0.1, colors=((1,0,0), (0,0,0)))



class SoilMoistureSensor:
    async def _do_measurement(self, probe_count : int = 100, probe_interval : float = 0.2) -> array.array :
        raw_moisture_probes = array.array('H')  # Array of unsigned short (16-bit) integers
        self._sensor_power.value(1)  
        await asyncio.sleep(1)  # Wait for sensor to stabilize
        for _ in range(probe_count):
            raw_probe = self._sensor.read_u16(last=False)
            raw_moisture_probes.append(raw_probe)
            await asyncio.sleep(probe_interval)
        self._sensor_power.value(0)  
        log.debug(f"Raw moisture probes: {raw_moisture_probes}")
        log.debug(f"Min: {min(raw_moisture_probes)}, "
                  f"Max: {max(raw_moisture_probes)}, "
                  f"Avg: {average(raw_moisture_probes)}, "
                  f"P25: {percentile(raw_moisture_probes, 25)}, "
                  f"P50: {percentile(raw_moisture_probes, 50)}, "
                  f"P75: {percentile(raw_moisture_probes, 75)}, "
                  f"P95: {percentile(raw_moisture_probes, 95)}")
        return raw_moisture_probes

    def __init__(self, sensor : AADC, sensor_power : Pin, probe_count : int = 100, probe_interval : float = 0.2) -> None:
        self._sensor = sensor
        self._sensor_power = sensor_power

        self._probe_count : int = probe_count
        self._probe_interval : float = probe_interval

        self._left_bound : int = 65535
        self._right_bound : int = 0

        self._settings_file = JsonFileUtil("HD-38-sensor-calibration.json")

    async def calibrate_dry_soil(self) :
        raw_moisture_probes = await self._do_measurement(self._probe_count, self._probe_interval)
        self._left_bound = int(average(raw_moisture_probes))

        if self._left_bound < self._right_bound:
            raise Exception("Invalid calibration values. Left bound must be greater than right bound.")

        log.debug(f"Calibration dry soil completed. Left bound: {self._left_bound}, Right bound: {self._right_bound}")
        
    async def calibrate_wet_soil(self) :
        raw_moisture_probes = await self._do_measurement(self._probe_count, self._probe_interval)    
        self._right_bound = int(average(raw_moisture_probes))

        if self._left_bound < self._right_bound:
            raise Exception("Invalid calibration values. Right bound must be less than left bound.")

        log.debug(f"Calibration wet soil completed. Left bound: {self._left_bound}, Right bound: {self._right_bound}")

    async def measure_soil_moisture(self) -> int:
        raw_moisture_probes = await self._do_measurement(self._probe_count, self._probe_interval)    
        moisture_level = int(average(raw_moisture_probes))
        moisture_percentage = int(percentage_in_bounds(moisture_level, self._left_bound, self._right_bound))
        
        log.debug(f"Measured soil moisture: {moisture_level}, Percentage: {moisture_percentage}")
        return moisture_percentage
    
    def reset(self):
        self._left_bound = 65535
        self._right_bound = 0
        log.debug("Calibration reset to default values")
        if self._settings_file.delete() is True:
            log.debug("Calibration settings file deleted")
        else:
            log.debug("No calibration settings file to delete")

    def store_calibration_settings(self):
        self._settings_file.rewrite({
            "left": self._left_bound,
            "right": self._right_bound
        })
        log.debug(f"Calibration settings saved. Left bound: {self._left_bound}, Right bound: {self._right_bound}")

    def load_calibration_settings(self) -> bool :
        data = self._settings_file.read()
        if data is None:
            log.debug("No calibration settings file found.")
            return False
        
        self._left_bound = int(data.get("left", self._left_bound))
        self._right_bound = int(data.get("right", self._right_bound))
        log.debug(f"Calibration settings loaded. Left={self._left_bound}, Right={self._right_bound}")
        return True
    
    
class ControlButton :
    def __init__(self, button : Pushbutton):
        self._button = button

    async def wait_press(self) :
        def _on_button_pressed(e : Event):
            e.set()
    
        event = Event()
        self._button.press_func(_on_button_pressed, (event,))
        await event.wait()
        event.clear()
    
    def subscribe_long_press(self, func, args=()):
        self._button.long_func(func, args)

    def subscribe_double_press(self, func, args=()):
        self._button.double_func(func, args)


class HomeAssistantClient:
    def _connect_wifi(self, name : str, password : str, attempts : int=10):
        wlan = network.WLAN(network.STA_IF)
        wlan.active(True)

        while not wlan.isconnected():
            log.debug(f"Connecting to WiFi {name}, attempts left: {attempts}")
            if attempts <= 0: 
                raise Exception("Failed to connect to WiFi. Exceeded maximum attempts.")
            wlan.connect(name, password)
            time.sleep(5)
            attempts -= 1
        log.debug(f"Connected to WiFi {name}, IP: {wlan.ifconfig()[0]}")
    
    def _connect_mqtt(self, host : str, client_id : str):
        log.debug(f"Connecting to MQTT broker at {host} with client ID {client_id}")

        self._client = MQTTClient(
            client_id=client_id,
            server=host,
            keepalive=5,
            port=1883)

        availability_topic = f"{client_id}/availability"
        self._client.set_last_will(availability_topic, b"offline", retain=True, qos=1)
        self._client.connect()
        self._client.publish(availability_topic, b"online", retain=True, qos=1)
    
    def _register_components(self, client_id : str):
        log.debug(f"Registering components for client ID {client_id}")

        soil_moisture_sensor = "HD_38_soil_moisture_sensor"
        self._soil_moisture_sensor_state_topic =  f"{client_id}/{soil_moisture_sensor}/state"
      
        config = {
            "device" : {
                "identifiers": client_id,
                "name": client_id,
                "manufacturer": "TheSonOfDeimos",
                "model": "Raspberry Pi Pico W"
            },
            "origin" : {
                "name": "SQM OS",
                "sw_version": "1.0"
            },
            "components": {
                soil_moisture_sensor: {
                    "unique_id": soil_moisture_sensor,
                    "platform": "sensor",
                    "device_class": "moisture",
                    "unit_of_measurement":"%",
                    "state_topic": self._soil_moisture_sensor_state_topic,
                }
            },
        }    
        self._client.publish(f"homeassistant/device/{client_id}/config", json.dumps(config), retain=True, qos=1)
    
    def __init__(self, wifi_ssid : str, wifi_psk : str, mqtt_host : str):
        self._wifi_ssid = wifi_ssid
        self._wifi_psk = wifi_psk
        self._mqtt_host = mqtt_host

    def connect(self):
        log.debug("Connecting to Home Assistant")

        device_id = "soil-quality-monitor"
        self._connect_wifi(name=self._wifi_ssid, password=self._wifi_psk)
        self._connect_mqtt(host=self._mqtt_host, client_id=device_id)
        self._register_components(device_id)

    def publish_soil_moisture(self, moisture_level: int, attempts: int = 10):
        log.debug(f"Publishing soil moisture level: {moisture_level}")

        if moisture_level < 0 or moisture_level > 100:
            raise ValueError("Moisture level must be between 0 and 100.")
        
        while True:
            if attempts <= 0:
                raise Exception("Failed to publish soil moisture after multiple attempts.")
            try:
                self._client.publish(self._soil_moisture_sensor_state_topic, ("%.1f" % moisture_level), retain=True, qos=1)
                log.debug("Soil moisture published successfully")
                return
            except Exception as e:
                attempts -= 1
                log.debug(f"Failed to publish soil moisture: {e}, reconnecting attempts left: {attempts}")
                self._client.connect(False)
        
class StateController:
    def __init__(self, ha_client : HomeAssistantClient, button : ControlButton, led : StatusLed, soilSensor : SoilMoistureSensor, wakeup_interval : float = 100) -> None:
        self._in_progress = False
        self._is_calibrated = False
        self._last_measurement = -1

        self._ha_client = ha_client
        self._button = button
        self._led = led
        self._soilSensor = soilSensor
        self._wakeup_interval = wakeup_interval

    async def run(self):
        try:
            self._in_progress = True
            log.info("Device initialization")

            self._led.connecting_to_network()
            self._ha_client.connect()

            self._button.subscribe_long_press(self.calibrate_device)
            self._button.subscribe_double_press(self.last_measurement)

            self._is_calibrated = self._soilSensor.load_calibration_settings()
            if self._is_calibrated is False:
                log.info("Device is not calibrated, starting calibration")
                self._in_progress = False
                await self.calibrate_device()
                self._in_progress = True

            log.info("Device is ready, running main loop")
            self._led.device_ready()
            await asyncio.sleep(5)
            self._led.idle()
            self._in_progress = False

            while True:
                await asyncio.sleep(self._wakeup_interval)
                await self.measure_soil_moisture()
            
        except Exception as e:
            log.error(e)
            self._led.fatal_error()
            await asyncio.sleep(5)
            raise

        finally:
            self._led.idle()
            self._in_progress = False

    async def last_measurement(self) :
        if self._in_progress is True:
            log.warning("Reject, anther operation is in progress")
            return
        
        if self._last_measurement < 0 :
            await self.measure_soil_moisture()
        else:
            try:
                self._in_progress = True
                log.info("Displaying last measurement")
                if self._is_calibrated is False:
                    raise Exception("Device is not calibrated")
                self._led.soil_moisture(self._last_measurement, 0, 100)
                await asyncio.sleep(5)
    
            except Exception as e:
                log.error(e)
                self._led.user_error()
                await asyncio.sleep(5)

            finally:
                self._led.idle()
                self._in_progress = False

    async def calibrate_device(self):
        if self._in_progress is True:
            log.warning("Reject, anther operation is in progress")
            return

        try:
            self._in_progress = True
            log.info("Calibrating soil moisture sensor")

            self._is_calibrated = False
            self._soilSensor.reset()

            self._led.start_calibration_soil_moisture_when_dry()
            await self._button.wait_press()

            self._led.calibrating_soil_moisture_when_dry()
            await self._soilSensor.calibrate_dry_soil()
            self._last_measurement = 0

            self._led.start_calibration_soil_moisture_when_wet()
            await self._button.wait_press()

            self._led.calibrating_soil_moisture_when_wet()
            await self._soilSensor.calibrate_wet_soil()
            self._last_measurement = 100

            self._soilSensor.store_calibration_settings()
            self._is_calibrated = True

        except Exception as e:
            log.error(e)
            self._led.user_error()
            await asyncio.sleep(5)

        finally:
            self._led.idle()
            self._in_progress = False

    async def measure_soil_moisture(self):
        if self._in_progress is True:
            log.warning("Reject, anther operation is in progress or device is not calibrated")
            return

        try:
            self._in_progress = True
            log.info("Measuring soil moisture")
            if self._is_calibrated is False:
                raise Exception("Device is not calibrated")

            self._led.measuring_soil_moisture()
            self._last_measurement = await self._soilSensor.measure_soil_moisture()
            
            self._led.soil_moisture(self._last_measurement, 0, 100)
            self._ha_client.publish_soil_moisture(self._last_measurement)
            await asyncio.sleep(5)

        except Exception as e:
            log.error(e)
            self._led.user_error()
            await asyncio.sleep(5)

        finally:
            self._led.idle()
            self._in_progress = False
            
async def main():
    log.set_level(Logger.DEBUG)

    ha_client = HomeAssistantClient("ZEYA", "pool-side-X", "192.168.1.34")
    button = ControlButton(Pushbutton(Pin(17, Pin.IN, Pin.PULL_UP)))
    led = StatusLed(RGBLED(red=12, green=11, blue=10, active_high=False))
    soilSensor = SoilMoistureSensor(AADC(ADC(27)), Pin(26, Pin.OUT, value=0), probe_count=100, probe_interval=0.2)

    controller = StateController(ha_client, button, led, soilSensor, wakeup_interval=400)
    await controller.run()

try:
    asyncio.run(main())
finally:
    _ = asyncio.new_event_loop()